
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\.gitignore =====
    # Logs
    logs
    *.log
    npm-debug.log*
    yarn-debug.log*
    yarn-error.log*
    pnpm-debug.log*
    lerna-debug.log*
    
    node_modules
    dist
    dist-ssr
    *.local
    
    # Editor directories and files
    .vscode/*
    !.vscode/extensions.json
    .idea
    .DS_Store
    *.suo
    *.ntvs*
    *.njsproj
    *.sln
    *.sw?
    
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\index.html =====
    <!-- index.html  (keep at project root) -->
    <!DOCTYPE html>
    <html lang="en">
    <head>
      <meta charset="utf-8" />
      <title>Typewriting Monkey</title>
    </head>
    <body>
      <pre id="output"></pre>
      <script type="module" src="/src/client/main.ts"></script>
    </body>
    </html>
     
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\package.json =====
    {
      "name": "typewriting-monkey",
      "version": "1.0.0",
      "description": "Typewriting Monkey",
      "main": "index.js",
      "scripts": {
        "dev:client": "vite",
        "dev:server": "tsx watch --tsconfig tsconfig.server.json src/server/app.ts",
        "dev:export": "tsx watch scripts/export.js --watch . --ignore node_modules --ignore dist",
        "dev": "concurrently -n client,server,export -c magenta,cyan,gray \"npm:dev:client\" \"npm:dev:server\" \"npm:dev:export\"",
        "build:client": "vite build",
        "build:server": "tsc -p tsconfig.server.json",
        "build": "npm run build:client && npm run build:server",
        "start": "node dist/server/app.js"
      },
      "repository": {
        "type": "git",
        "url": "git+https://github.com/Squidsword/typewriting-monkey.git"
      },
      "author": "Max Everest",
      "license": "ISC",
      "bugs": {
        "url": "https://github.com/Squidsword/typewriting-monkey/issues"
      },
      "homepage": "https://github.com/Squidsword/typewriting-monkey#readme",
      "dependencies": {
        "express": "^5.1.0",
        "seedrandom": "^3.0.5",
        "socket.io": "^4.8.1",
        "socket.io-client": "^4.8.1"
      },
      "devDependencies": {
        "@types/express": "^5.0.1",
        "@types/node": "^22.15.3",
        "@types/seedrandom": "^3.0.8",
        "@types/socket.io": "^3.0.1",
        "@types/socket.io-client": "^1.4.36",
        "@vitejs/plugin-react": "^4.0.0",
        "concurrently": "^9.1.2",
        "minimatch": "^10.0.1",
        "tsx": "^4.19.4",
        "typescript": "^5.8.3",
        "vite": "^5.0.0"
      }
    }
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\client\main.ts =====
    /**
     * Browser-side entry point.
     * - Opens a Socket.IO connection to receive live characters + word hits
     * - Fetches missing historical chunks on demand via `/chars`
     * - Renders the ever-growing text, highlighting discovered words
     */
    
    import io from 'socket.io-client';
    import './styles.css';
    
    // ---------------------------------------------------------------------------
    // Type helpers mirroring server events
    // ---------------------------------------------------------------------------
    interface MonkeyEvt { index: number; ch: string }
    interface WordHit   { start: number; len: number }
    
    // Tunables — must match server values ---------------------------------------
    const CHUNK = 8192;
    
    // Client-side cache ----------------------------------------------------------
    const chunks: Record<number, string> = {}; // chunkId → text
    const hits:   WordHit[] = [];             // all word hits seen so far
    let   cursor  = 0;                        // next global char index
    
    const out = document.getElementById('output') as HTMLPreElement;
    
    // ---------------------------------------------------------------------------
    // Helpers
    // ---------------------------------------------------------------------------
    /** Lazy-load a chunk only once. */
    const getChunk = async (id: number) => {
      if (chunks[id] !== undefined) return;
    
      const r = await fetch(`/chars?start=${id * CHUNK}&len=${CHUNK}`);
      if (r.ok) chunks[id] = await r.text();
    };
    
    /** Concatenate cached chunks up to (but not including) `cursor`. */
    const fullText = (): string => {
      const lastChunk = Math.floor(cursor / CHUNK);
    
      let result = '';
      for (let i = 0; i <= lastChunk; i++) {
        const data = chunks[i] ?? '';
        result += i === lastChunk ? data.slice(0, cursor % CHUNK) : data;
      }
      return result;
    };
    
    /**
     * Deduplicate overlapping WordHits (prefer longer ones when nested).
     * Returns a list sorted by ascending `start`.
     */
    const nonOverlappingHits = (raw: WordHit[]): WordHit[] => {
      const sorted = [...raw].sort((a, b) => a.start - b.start || b.len - a.len);
      const output: WordHit[] = [];
    
      sorted.forEach(hit => {
        const last = output.at(-1);
        if (!last || hit.start >= last.start + last.len) output.push(hit);
      });
      return output;
    };
    
    /** Render the current text + word highlights into the <pre>. */
    const render = () => {
      const t = fullText();
      const visibleWords = nonOverlappingHits(hits.filter(h => h.start < t.length));
    
      let html = '';
      let ptr  = 0;
    
      visibleWords.forEach(h => {
        html += t.slice(ptr, h.start);                        // plain segment
        html += `<span class="word len${h.len}">${t.slice(    // highlighted word
                 h.start, h.start + h.len)}</span>`;
        ptr = h.start + h.len;
      });
      html += t.slice(ptr);                                   // tail segment
      out.innerHTML = html;
    };
    
    // ---------------------------------------------------------------------------
    // Live wiring
    // ---------------------------------------------------------------------------
    (async () => {
      const sock = io();
    
      // Initial state ----------------------------------------------------------
      sock.on('cursor', async (c: number) => {
        cursor = c;
    
        // Pre-fetch all chunks up to the current cursor
        const last = Math.floor(cursor / CHUNK);
        for (let id = 0; id <= last; id++) await getChunk(id);
    
        render();
      });
    
      sock.on('init-words', (initial: WordHit[]) => {
        hits.push(...initial);
        render();
      });
    
      // Incremental updates ----------------------------------------------------
      sock.on('word', (hit: WordHit) => {
        hits.push(hit);
        render();
      });
    
      sock.on('monkey-type', async ({ index, ch }: MonkeyEvt) => {
        const id  = Math.floor(index / CHUNK);
        const off = index % CHUNK;
    
        await getChunk(id); // ensure chunk is present before patching
    
        // splice the new character into its cached chunk
        chunks[id] = chunks[id].slice(0, off) + ch + chunks[id].slice(off + 1);
        cursor = index + 1;
    
        render();
      });
    })();
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\client\styles.css =====
    :root {
        --bg:#222831;
        --fg:#DFD0B8;
        --accent:#4dabff;
    }
    
    @media (prefers-color-scheme: dark) {
        :root {
            --bg:#222831;
            --fg:#DFD0B8;
            --accent:#4dabff;
        }
    }
    
    html, body {
        background:var(--bg);
        color:var(--fg);
    }
    
    #output {
        white-space:pre-wrap;
        word-break:break-all;
    }
    
    .word {
        margin:0 0.35ch;
    }
    .word.len3 { color:hsl(37, 38%, 64%); }
    .word.len4 { color:hsl(357, 38%, 64%); }
    .word.len5 { color:hsl(317, 38%, 64%); }
    .word.len6 { color:hsl(277, 38%, 64%); }
    .word.len7 { color:hsl(237, 38%, 64%)}
    .word.len8 { color:hsl(197, 38%, 64%) }
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\server\app.ts =====
    /**
     * Entry-point for the Node server.
     * - Serves static client assets from `../public`
     * - Streams characters generated by the Monkey to connected Socket.IO clients
     * - Exposes a small REST endpoint (`/chars`) so the browser can fetch historical
     *   chunks that already scrolled off the live stream.
     */
    
    import express            from 'express';
    import { createServer }   from 'http';
    import { Server }         from 'socket.io';
    import path               from 'path';
    
    import { Monkey }              from './monkey';
    import { read, CHUNK }         from './chunk-store';
    import { WordDetector, type WordHit } from './word-detector';
    
    // ────────────────────────────────────────────────────────────────────────────────
    // Bootstrapping
    // ────────────────────────────────────────────────────────────────────────────────
    const app  = express();           // Express HTTP layer
    const http = createServer(app);   // Plain HTTP server (needed for socket.io)
    const io   = new Server(http);    // WebSocket transport
    
    // Domain objects ---------------------------------------------------------------
    const monkey   = new Monkey();      // Generates pseudo-random lowercase letters
    const detector = new WordDetector(); // Emits "word" events on valid hits
    const found: WordHit[] = [];        // All words found so far (shared w/ clients)
    
    // Static file hosting ----------------------------------------------------------
    app.use(express.static(path.join(__dirname, '../public')));
    
    /**
     * GET /chars?start=0&len=1024
     * Random–access API so the browser can fetch any slice of previously
     * generated text.  Guards defend against obviously bad requests.
     */
    app.get('/chars', (req, res) => {
      const start = Number(req.query.start);
      const len   = Number(req.query.len);
    
      if (
        Number.isNaN(start) || Number.isNaN(len) ||
        start < 0 || len <= 0 || len > CHUNK * 4
      ) {
        res.status(400).end();
      } else {
        res.type('text/plain').send(read(start, len));
      }
    
    });
    
    // WebSocket lifecycle -----------------------------------------------------------
    io.on('connection', socket => {
      socket.emit('cursor',     monkey.cursor); // where the monkey is now
      socket.emit('init-words', found);         // all words discovered so far
    });
    
    // Main loop: have the monkey type every 100 ms -------------------------------
    setInterval(() => {
      const { index, ch } = monkey.next();      // 1. generate next char
      detector.push(ch);                        // 2. check for new word hits
      io.emit('monkey-type', { index, ch });    // 3. broadcast to everyone
    }, 100);
    
    // Word detection side-channel -----------------------------------------------
    detector.on('word', hit => {
      found.push(hit);
      io.emit('word', hit);                     // notify browsers of the new word
    });
    
    // Start listening --------------------------------------------------------------
    http.listen(5500, () => console.log('Server listening on :5500'));
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\server\chunk-store.ts =====
    /**
     * Extremely simple append-only chunk store.
     * The monkey writes sequentially, and readers can request arbitrary slices.
     */
    
    export const CHUNK = 8_192;                 // 8 KiB per chunk
    
    /** id → text (may be shorter than CHUNK if we haven’t filled the file yet). */
    const chunks = new Map<number, string>();
    
    /** Append raw text to the given chunk id. */
    export const append = (id: number, data: string): void => {
      const existing = chunks.get(id) ?? '';
      chunks.set(id, existing + data);
    };
    
    /**
     * Random-access read across as many chunks as necessary.
     * Always returns exactly `len` characters (or fewer if we haven’t generated
     * that far yet).
     */
    export const read = (start: number, len: number): string => {
      const first = Math.floor(start / CHUNK);
      const last  = Math.floor((start + len - 1) / CHUNK);
    
      let buffer = '';
      for (let id = first; id <= last; id++) buffer += chunks.get(id) ?? '';
    
      const offset = start - first * CHUNK;
      return buffer.slice(offset, offset + len);
    };
    
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\server\monkey.ts =====
    /**
     * Pseudo-random “monkey” that types a-z characters forever.
     * Persists the output in memory in CHUNK-sized entries via `chunk-store.ts`.
     */
    
    import seedrandom          from 'seedrandom';
    import { CHUNK, append }   from './chunk-store';
    
    export class Monkey {
      /** Fixed seed so multiple runs produce the same stream. */
      private rng = seedrandom('lunaleo');
    
      /** Global cursor: absolute index of the *next* character to type. */
      private _cursor = 0;
      get cursor() { return this._cursor; }
    
      /** Generate the next character */
      next(): { index: number; ch: string } {
        const ch  = String.fromCharCode(97 + Math.floor(this.rng() * 26)); // 'a'…'z'
        const idx = this._cursor++;
        
        /** Assign character to proper CHUNK **/
        append(Math.floor(idx / CHUNK), ch); 
    
        /** Return streamed character information */
        return { index: idx, ch };
      }
    
    }
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\server\word-detector.ts =====
    /**
     * Sliding-window detector that emits a “word” event whenever a valid English
     * word (length ≥ 3) ends at the current cursor position.
     *
     * 1. Load dictionary from ../data/words.txt at startup.
     * 2. Keep a moving buffer of up to MAX_LEN recent chars.
     * 3. On every push(), scan from longest→shortest prospective word; emit once.
     */
    
    import fs           from 'fs';
    import path         from 'path';
    import { EventEmitter } from 'events';
    
    // ----------------------------------------------------------------------------
    // Dictionary setup
    // ----------------------------------------------------------------------------
    const MIN_LEN = 3;
    const WORDS_FILE = path.join(__dirname, '../data/words.txt');
    
    const WORDS = new Set(
      fs.readFileSync(WORDS_FILE, 'utf8')
        .split(/\r?\n/)
        .filter(w => w.length >= MIN_LEN)
    );
    
    const MAX_LEN = 12;
    
    // ----------------------------------------------------------------------------
    // Types
    // ----------------------------------------------------------------------------
    export interface WordHit { start: number; len: number }
    
    // ----------------------------------------------------------------------------
    // Detector
    // ----------------------------------------------------------------------------
    export class WordDetector extends EventEmitter {
      private window = '';  // sliding buffer (≤ MAX_LEN)
      private cursor = 0;   // index *after* the most recently pushed char
    
      /**
       * Feed a single character into the detector.
       * Returns the cursor *before* the push (mirrors original behaviour).
       */
      push(ch: string): number {
        this.window += ch;
        if (this.window.length > MAX_LEN) this.window = this.window.slice(1);
    
        this.scanForWord();
        return this.cursor++;
      }
    
      /** Scan the current buffer for the *longest* valid word that ends here. */
      private scanForWord(): void {
        for (let n = Math.min(MAX_LEN, this.window.length); n >= MIN_LEN; n--) {
          const candidate = this.window.slice(-n);
          if (WORDS.has(candidate)) {
            this.emit('word', { start: this.cursor - n + 1, len: n } as WordHit);
            break; // emit only the longest match
          }
        }
      }
    }
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\src\vite-env.d.ts =====
    /// <reference types="vite/client" />
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\tsconfig.client.json =====
    {
      "compilerOptions": {
        "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
        "target": "ES2020",
        "useDefineForClassFields": true,
        "lib": ["ES2020", "DOM", "DOM.Iterable"],
        "module": "ESNext",
        "skipLibCheck": true,
    
        /* Bundler mode */
        "moduleResolution": "bundler",
        "allowImportingTsExtensions": true,
        "verbatimModuleSyntax": true,
        "moduleDetection": "force",
        "noEmit": true,
        "jsx": "react-jsx",
    
        /* Linting */
        "strict": true,
        "noUnusedLocals": true,
        "noUnusedParameters": true,
        "erasableSyntaxOnly": true,
        "noFallthroughCasesInSwitch": true,
        "noUncheckedSideEffectImports": true
      },
      "include": ["src"]
    }
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\tsconfig.json =====
    {
      "files": [],
      "references": [
        { "path": "./tsconfig.client.json" },
        { "path": "./tsconfig.server.json" }
      ]
    }
    
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\tsconfig.server.json =====
    {
        "compilerOptions": {
          "target": "ES2022",
          "lib": ["ES2022"],
          "outDir": "./dist/server",
      
          "module": "CommonJS",
          "moduleResolution": "node",          // ⬅️ overrides “bundler”
          "allowImportingTsExtensions": false, // ⬅️ turn it off
      
          "esModuleInterop": true,
          "strict": true,
          "skipLibCheck": true
        },
        "include": ["src/server"]
      }
      
===== C:\Users\Squidsword\Documents\2maxDocuments\CodingProjects\typewriting-monkey\vite.config.ts =====
    import { defineConfig } from 'vite'
    import react from '@vitejs/plugin-react'
    
    export default defineConfig({
      root: '.',                 // project root
      publicDir: 'public',       // unchanged
      build: { outDir: 'dist/client', emptyOutDir: true },
      server: {
        port: 5173,
        proxy: {
          '/socket.io': 'http://localhost:5500',
          '/chars': 'http://localhost:5500'
        }
      }
    })
    